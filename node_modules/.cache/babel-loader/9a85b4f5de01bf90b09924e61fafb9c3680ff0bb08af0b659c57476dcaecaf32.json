{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nimport { sampleDatasets } from '../constants/datasets';\nimport { vehicleColors } from '../constants/vehicleColors';\nimport { solveTspNearestNeighbor } from '../algorithms/solveTsp';\nimport { getDistance, calculateRouteDistance } from '../algorithms/geometry';\nconst getInitialState = datasetName => {\n  const data = sampleDatasets[datasetName];\n  const allNodes = [data.depot, ...data.customers];\n  const nodeMap = allNodes.reduce((acc, node) => {\n    acc[node.id] = node;\n    return acc;\n  }, {});\n  return {\n    dataset: data,\n    depot: data.depot,\n    capacity: data.capacity,\n    allNodesMap: nodeMap,\n    customerNodes: data.customers,\n    unvisitedCustomerIds: data.customers.map(c => c.id),\n    vehicles: [],\n    currentVehicleId: 0,\n    algorithmState: 'idle',\n    animationState: 'paused',\n    animationSpeed: 500,\n    logMessages: ['Select a dataset and press Play.'],\n    totalDistance: 0\n  };\n};\nexport const useCvrpAlgorithm = initialDatasetName => {\n  _s();\n  const [selectedDataset, setSelectedDataset] = useState(initialDatasetName);\n  const [state, setState] = useState(() => getInitialState(initialDatasetName));\n  const addLog = message => {\n    setState(prevState => ({\n      ...prevState,\n      logMessages: [...prevState.logMessages, message]\n    }));\n  };\n  const startNewVehicle = useCallback(() => {\n    if (state.unvisitedCustomerIds.length === 0) {\n      addLog(\"All customers served.\");\n      setState(s => ({\n        ...s,\n        algorithmState: 'done',\n        animationState: 'paused'\n      }));\n      return;\n    }\n    const newVehicleId = state.currentVehicleId + 1;\n    const newVehicle = {\n      id: newVehicleId,\n      route: [state.depot],\n      capacityLeft: state.capacity,\n      initialCapacity: state.capacity,\n      color: vehicleColors[newVehicleId % vehicleColors.length]\n    };\n    const startCustomerId = state.unvisitedCustomerIds[0];\n    const startCustomer = state.allNodesMap[startCustomerId];\n    if (startCustomer.demand > newVehicle.capacityLeft) {\n      addLog(`Error: Customer ${startCustomer.id} demand (${startCustomer.demand}) exceeds vehicle capacity (${state.capacity}). Stopping.`);\n      setState(s => ({\n        ...s,\n        algorithmState: 'done',\n        animationState: 'paused'\n      }));\n      return;\n    }\n    newVehicle.route.push(startCustomer);\n    newVehicle.capacityLeft -= startCustomer.demand;\n    const newUnvisitedIds = state.unvisitedCustomerIds.filter(id => id !== startCustomerId);\n    addLog(`Starting Vehicle ${newVehicleId} at Depot.`);\n    addLog(`Vehicle ${newVehicleId}: Add first customer ${startCustomer.id} (Demand: ${startCustomer.demand}, Capacity Left: ${newVehicle.capacityLeft})`);\n    setState(prevState => ({\n      ...prevState,\n      vehicles: [...prevState.vehicles, newVehicle],\n      currentVehicleId: newVehicleId,\n      unvisitedCustomerIds: newUnvisitedIds,\n      algorithmState: 'clustering'\n    }));\n  }, [state.unvisitedCustomerIds, state.depot, state.capacity, state.allNodesMap, state.currentVehicleId]);\n  const clusteringStep = useCallback(() => {\n    const currentVehicle = state.vehicles.find(v => v.id === state.currentVehicleId);\n    if (!currentVehicle) return;\n    const availableCustomerIds = state.unvisitedCustomerIds.filter(id => state.allNodesMap[id].demand <= currentVehicle.capacityLeft);\n    if (availableCustomerIds.length === 0) {\n      addLog(`Vehicle ${state.currentVehicleId}: No more customers fit. Finalizing route.`);\n      setState(s => ({\n        ...s,\n        algorithmState: 'solving_tsp'\n      }));\n      return;\n    }\n    let bestCustomerId = -1;\n    let minDistance = Infinity;\n    for (const routeNode of currentVehicle.route) {\n      for (const customerId of availableCustomerIds) {\n        const customerNode = state.allNodesMap[customerId];\n        const distance = getDistance(routeNode, customerNode);\n        if (distance < minDistance) {\n          minDistance = distance;\n          bestCustomerId = customerId;\n        }\n      }\n    }\n    if (bestCustomerId !== -1) {\n      const bestCustomer = state.allNodesMap[bestCustomerId];\n      const newRoute = [...currentVehicle.route, bestCustomer];\n      const newCapacityLeft = currentVehicle.capacityLeft - bestCustomer.demand;\n      const newUnvisitedIds = state.unvisitedCustomerIds.filter(id => id !== bestCustomerId);\n      const newVehicles = state.vehicles.map(v => v.id === state.currentVehicleId ? {\n        ...v,\n        route: newRoute,\n        capacityLeft: newCapacityLeft\n      } : v);\n      addLog(`Vehicle ${state.currentVehicleId}: Add customer ${bestCustomer.id} (Demand: ${bestCustomer.demand}, Capacity Left: ${newCapacityLeft})`);\n      setState(s => ({\n        ...s,\n        vehicles: newVehicles,\n        unvisitedCustomerIds: newUnvisitedIds\n      }));\n    } else {\n      addLog(`Vehicle ${state.currentVehicleId}: No suitable customer found. Finalizing route.`);\n      setState(s => ({\n        ...s,\n        algorithmState: 'solving_tsp'\n      }));\n    }\n  }, [state.vehicles, state.currentVehicleId, state.unvisitedCustomerIds, state.allNodesMap]);\n  const solveTspStep = useCallback(() => {\n    const currentVehicle = state.vehicles.find(v => v.id === state.currentVehicleId);\n    if (!currentVehicle) return;\n    addLog(`Vehicle ${state.currentVehicleId}: Solving TSP for ${currentVehicle.route.length - 1} customers...`);\n    const clusterNodes = currentVehicle.route;\n    const optimizedRoute = solveTspNearestNeighbor(clusterNodes, state.depot);\n    const routeDistance = calculateRouteDistance(optimizedRoute);\n    const newVehicles = state.vehicles.map(v => v.id === state.currentVehicleId ? {\n      ...v,\n      route: optimizedRoute\n    } : v);\n    addLog(`Vehicle ${state.currentVehicleId}: Route optimized (NN). Distance: ${routeDistance.toFixed(2)}`);\n    setState(s => ({\n      ...s,\n      vehicles: newVehicles,\n      totalDistance: s.totalDistance + routeDistance,\n      algorithmState: 'idle'\n    }));\n  }, [state.vehicles, state.currentVehicleId, state.depot]);\n  useEffect(() => {\n    if (state.animationState === 'playing' && state.algorithmState !== 'done') {\n      const timer = setTimeout(() => {\n        if (state.algorithmState === 'idle') startNewVehicle();else if (state.algorithmState === 'clustering') clusteringStep();else if (state.algorithmState === 'solving_tsp') solveTspStep();\n      }, state.animationSpeed);\n      return () => clearTimeout(timer);\n    }\n  }, [state.animationState, state.algorithmState, state.animationSpeed, startNewVehicle, clusteringStep, solveTspStep]);\n  const handlePlayPause = () => {\n    if (state.algorithmState === 'done') return;\n    setState(s => ({\n      ...s,\n      animationState: s.animationState === 'playing' ? 'paused' : 'playing'\n    }));\n  };\n  const handleNextStep = () => {\n    if (state.animationState === 'playing' || state.algorithmState === 'done') return;\n    if (state.algorithmState === 'idle') startNewVehicle();else if (state.algorithmState === 'clustering') clusteringStep();else if (state.algorithmState === 'solving_tsp') solveTspStep();\n  };\n  const handleReset = () => {\n    setState(getInitialState(selectedDataset));\n  };\n  const handleDatasetChange = datasetName => {\n    setSelectedDataset(datasetName);\n    setState(getInitialState(datasetName));\n  };\n  const handleSpeedChange = speed => {\n    setState(s => ({\n      ...s,\n      animationSpeed: speed\n    }));\n  };\n  return {\n    state,\n    selectedDataset,\n    handlePlayPause,\n    handleNextStep,\n    handleReset,\n    handleDatasetChange,\n    handleSpeedChange\n  };\n};\n_s(useCvrpAlgorithm, \"gVhGNb3h+xHvcVdPpQb6jBIstzA=\");","map":{"version":3,"names":["useState","useCallback","useEffect","sampleDatasets","vehicleColors","solveTspNearestNeighbor","getDistance","calculateRouteDistance","getInitialState","datasetName","data","allNodes","depot","customers","nodeMap","reduce","acc","node","id","dataset","capacity","allNodesMap","customerNodes","unvisitedCustomerIds","map","c","vehicles","currentVehicleId","algorithmState","animationState","animationSpeed","logMessages","totalDistance","useCvrpAlgorithm","initialDatasetName","_s","selectedDataset","setSelectedDataset","state","setState","addLog","message","prevState","startNewVehicle","length","s","newVehicleId","newVehicle","route","capacityLeft","initialCapacity","color","startCustomerId","startCustomer","demand","push","newUnvisitedIds","filter","clusteringStep","currentVehicle","find","v","availableCustomerIds","bestCustomerId","minDistance","Infinity","routeNode","customerId","customerNode","distance","bestCustomer","newRoute","newCapacityLeft","newVehicles","solveTspStep","clusterNodes","optimizedRoute","routeDistance","toFixed","timer","setTimeout","clearTimeout","handlePlayPause","handleNextStep","handleReset","handleDatasetChange","handleSpeedChange","speed"],"sources":["C:/Users/ASUS/OneDrive/Desktop/cvrp-visualizer/src/hooks/useCvrpAlgorithm.js"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\r\nimport { sampleDatasets } from '../constants/datasets';\r\nimport { vehicleColors } from '../constants/vehicleColors';\r\nimport { solveTspNearestNeighbor } from '../algorithms/solveTsp';\r\nimport { getDistance, calculateRouteDistance } from '../algorithms/geometry';\r\n\r\nconst getInitialState = (datasetName) => {\r\n  const data = sampleDatasets[datasetName];\r\n  const allNodes = [data.depot, ...data.customers];\r\n  const nodeMap = allNodes.reduce((acc, node) => {\r\n    acc[node.id] = node;\r\n    return acc;\r\n  }, {});\r\n  \r\n  return {\r\n    dataset: data,\r\n    depot: data.depot,\r\n    capacity: data.capacity,\r\n    allNodesMap: nodeMap,\r\n    customerNodes: data.customers,\r\n    unvisitedCustomerIds: data.customers.map(c => c.id),\r\n    vehicles: [],\r\n    currentVehicleId: 0,\r\n    algorithmState: 'idle',\r\n    animationState: 'paused',\r\n    animationSpeed: 500,\r\n    logMessages: ['Select a dataset and press Play.'],\r\n    totalDistance: 0,\r\n  };\r\n};\r\n\r\nexport const useCvrpAlgorithm = (initialDatasetName) => {\r\n  const [selectedDataset, setSelectedDataset] = useState(initialDatasetName);\r\n  const [state, setState] = useState(() => getInitialState(initialDatasetName));\r\n\r\n  const addLog = (message) => {\r\n    setState(prevState => ({\r\n      ...prevState,\r\n      logMessages: [...prevState.logMessages, message],\r\n    }));\r\n  };\r\n\r\n  const startNewVehicle = useCallback(() => {\r\n    if (state.unvisitedCustomerIds.length === 0) {\r\n      addLog(\"All customers served.\");\r\n      setState(s => ({ ...s, algorithmState: 'done', animationState: 'paused' }));\r\n      return;\r\n    }\r\n    \r\n    const newVehicleId = state.currentVehicleId + 1;\r\n    const newVehicle = {\r\n      id: newVehicleId,\r\n      route: [state.depot],\r\n      capacityLeft: state.capacity,\r\n      initialCapacity: state.capacity,\r\n      color: vehicleColors[newVehicleId % vehicleColors.length],\r\n    };\r\n    \r\n    const startCustomerId = state.unvisitedCustomerIds[0];\r\n    const startCustomer = state.allNodesMap[startCustomerId];\r\n\r\n    if (startCustomer.demand > newVehicle.capacityLeft) {\r\n       addLog(`Error: Customer ${startCustomer.id} demand (${startCustomer.demand}) exceeds vehicle capacity (${state.capacity}). Stopping.`);\r\n       setState(s => ({ ...s, algorithmState: 'done', animationState: 'paused' }));\r\n       return;\r\n    }\r\n\r\n    newVehicle.route.push(startCustomer);\r\n    newVehicle.capacityLeft -= startCustomer.demand;\r\n    \r\n    const newUnvisitedIds = state.unvisitedCustomerIds.filter(id => id !== startCustomerId);\r\n\r\n    addLog(`Starting Vehicle ${newVehicleId} at Depot.`);\r\n    addLog(`Vehicle ${newVehicleId}: Add first customer ${startCustomer.id} (Demand: ${startCustomer.demand}, Capacity Left: ${newVehicle.capacityLeft})`);\r\n\r\n    setState(prevState => ({\r\n      ...prevState,\r\n      vehicles: [...prevState.vehicles, newVehicle],\r\n      currentVehicleId: newVehicleId,\r\n      unvisitedCustomerIds: newUnvisitedIds,\r\n      algorithmState: 'clustering',\r\n    }));\r\n  }, [state.unvisitedCustomerIds, state.depot, state.capacity, state.allNodesMap, state.currentVehicleId]);\r\n\r\n  const clusteringStep = useCallback(() => {\r\n    const currentVehicle = state.vehicles.find(v => v.id === state.currentVehicleId);\r\n    if (!currentVehicle) return;\r\n\r\n    const availableCustomerIds = state.unvisitedCustomerIds.filter(\r\n      id => state.allNodesMap[id].demand <= currentVehicle.capacityLeft\r\n    );\r\n\r\n    if (availableCustomerIds.length === 0) {\r\n      addLog(`Vehicle ${state.currentVehicleId}: No more customers fit. Finalizing route.`);\r\n      setState(s => ({ ...s, algorithmState: 'solving_tsp' }));\r\n      return;\r\n    }\r\n\r\n    let bestCustomerId = -1;\r\n    let minDistance = Infinity;\r\n\r\n    for (const routeNode of currentVehicle.route) {\r\n      for (const customerId of availableCustomerIds) {\r\n        const customerNode = state.allNodesMap[customerId];\r\n        const distance = getDistance(routeNode, customerNode);\r\n        \r\n        if (distance < minDistance) {\r\n          minDistance = distance;\r\n          bestCustomerId = customerId;\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (bestCustomerId !== -1) {\r\n      const bestCustomer = state.allNodesMap[bestCustomerId];\r\n      \r\n      const newRoute = [...currentVehicle.route, bestCustomer];\r\n      const newCapacityLeft = currentVehicle.capacityLeft - bestCustomer.demand;\r\n      const newUnvisitedIds = state.unvisitedCustomerIds.filter(id => id !== bestCustomerId);\r\n      \r\n      const newVehicles = state.vehicles.map(v => \r\n        v.id === state.currentVehicleId ? { ...v, route: newRoute, capacityLeft: newCapacityLeft } : v\r\n      );\r\n\r\n      addLog(`Vehicle ${state.currentVehicleId}: Add customer ${bestCustomer.id} (Demand: ${bestCustomer.demand}, Capacity Left: ${newCapacityLeft})`);\r\n\r\n      setState(s => ({\r\n        ...s,\r\n        vehicles: newVehicles,\r\n        unvisitedCustomerIds: newUnvisitedIds,\r\n      }));\r\n      \r\n    } else {\r\n      addLog(`Vehicle ${state.currentVehicleId}: No suitable customer found. Finalizing route.`);\r\n      setState(s => ({ ...s, algorithmState: 'solving_tsp' }));\r\n    }\r\n  }, [state.vehicles, state.currentVehicleId, state.unvisitedCustomerIds, state.allNodesMap]);\r\n  \r\n  const solveTspStep = useCallback(() => {\r\n    const currentVehicle = state.vehicles.find(v => v.id === state.currentVehicleId);\r\n    if (!currentVehicle) return;\r\n\r\n    addLog(`Vehicle ${state.currentVehicleId}: Solving TSP for ${currentVehicle.route.length - 1} customers...`);\r\n    const clusterNodes = currentVehicle.route;\r\n    const optimizedRoute = solveTspNearestNeighbor(clusterNodes, state.depot);\r\n    const routeDistance = calculateRouteDistance(optimizedRoute);\r\n\r\n    const newVehicles = state.vehicles.map(v =>\r\n      v.id === state.currentVehicleId ? { ...v, route: optimizedRoute } : v\r\n    );\r\n    \r\n    addLog(`Vehicle ${state.currentVehicleId}: Route optimized (NN). Distance: ${routeDistance.toFixed(2)}`);\r\n\r\n    setState(s => ({\r\n      ...s,\r\n      vehicles: newVehicles,\r\n      totalDistance: s.totalDistance + routeDistance,\r\n      algorithmState: 'idle',\r\n    }));\r\n  }, [state.vehicles, state.currentVehicleId, state.depot]);\r\n\r\n  useEffect(() => {\r\n    if (state.animationState === 'playing' && state.algorithmState !== 'done') {\r\n      const timer = setTimeout(() => {\r\n        if (state.algorithmState === 'idle') startNewVehicle();\r\n        else if (state.algorithmState === 'clustering') clusteringStep();\r\n        else if (state.algorithmState === 'solving_tsp') solveTspStep();\r\n      }, state.animationSpeed);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [state.animationState, state.algorithmState, state.animationSpeed, startNewVehicle, clusteringStep, solveTspStep]);\r\n\r\n  const handlePlayPause = () => {\r\n    if (state.algorithmState === 'done') return;\r\n    setState(s => ({\r\n      ...s,\r\n      animationState: s.animationState === 'playing' ? 'paused' : 'playing',\r\n    }));\r\n  };\r\n  \r\n  const handleNextStep = () => {\r\n    if (state.animationState === 'playing' || state.algorithmState === 'done') return;\r\n    if (state.algorithmState === 'idle') startNewVehicle();\r\n    else if (state.algorithmState === 'clustering') clusteringStep();\r\n    else if (state.algorithmState === 'solving_tsp') solveTspStep();\r\n  };\r\n  \r\n  const handleReset = () => {\r\n    setState(getInitialState(selectedDataset));\r\n  };\r\n  \r\n  const handleDatasetChange = (datasetName) => {\r\n    setSelectedDataset(datasetName);\r\n    setState(getInitialState(datasetName));\r\n  };\r\n  \r\n  const handleSpeedChange = (speed) => {\r\n    setState(s => ({ ...s, animationSpeed: speed }));\r\n  };\r\n\r\n  return {\r\n    state,\r\n    selectedDataset,\r\n    handlePlayPause,\r\n    handleNextStep,\r\n    handleReset,\r\n    handleDatasetChange,\r\n    handleSpeedChange\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}