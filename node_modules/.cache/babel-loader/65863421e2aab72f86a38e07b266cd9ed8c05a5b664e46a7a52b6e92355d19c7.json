{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { sampleDatasets } from '../constants/datasets';\nimport { vehicleColors } from '../constants/vehicleColors';\nimport { ALGORITHM_TYPES, COMPARISON_COLORS } from '../constants/algorithms';\nimport { runAlgorithmStep, runMetaheuristic, hybridGreedyStep } from '../algorithms';\nconst getInitialState = datasetName => {\n  const data = sampleDatasets[datasetName];\n  const allNodes = [data.depot, ...data.customers];\n  const nodeMap = allNodes.reduce((acc, node) => {\n    acc[node.id] = node;\n    return acc;\n  }, {});\n  return {\n    dataset: data,\n    depot: data.depot,\n    capacity: data.capacity,\n    allNodesMap: nodeMap,\n    customerNodes: data.customers,\n    unvisitedCustomerIds: data.customers.map(c => c.id),\n    vehicles: [],\n    currentVehicleId: 0,\n    vehicleColors: vehicleColors,\n    algorithmState: 'idle',\n    algorithmType: ALGORITHM_TYPES.GREEDY_HYBRID,\n    animationState: 'paused',\n    logMessages: [`Selected dataset: ${datasetName}. Select an algorithm and run.`],\n    totalDistance: 0,\n    comparisonResults: []\n  };\n};\nexport const useCvrpAlgorithm = initialDatasetName => {\n  _s();\n  const [selectedDataset, setSelectedDataset] = useState(initialDatasetName);\n  const [state, setState] = useState(() => getInitialState(initialDatasetName));\n  const addLog = message => {\n    setState(prevState => ({\n      ...prevState,\n      logMessages: [...prevState.logMessages, message]\n    }));\n  };\n  const runStep = useCallback(() => {\n    if (state.algorithmState === 'done') return;\n    const currentStateForAlgorithm = {\n      ...state,\n      vehicles: state.vehicles.map(v => ({\n        ...v,\n        route: v.route.map(n => state.allNodesMap[n.id])\n      }))\n    };\n    const result = runAlgorithmStep(state.algorithmType, currentStateForAlgorithm);\n    if (result.message) {\n      addLog(result.message);\n    }\n    if (result.newState) {\n      setState(s => ({\n        ...s,\n        ...result.newState\n      }));\n    } else if (result.nextState) {\n      setState(s => ({\n        ...s,\n        algorithmState: result.nextState\n      }));\n    }\n  }, [state]);\n  const runMetaheuristicFull = useCallback(() => {\n    addLog(`Running ${state.algorithmType} in full optimization mode...`);\n    setState(s => ({\n      ...s,\n      comparisonResults: [],\n      animationState: 'running',\n      algorithmState: 'running'\n    }));\n    const currentStateForAlgorithm = {\n      ...state,\n      vehicles: state.vehicles.map(v => ({\n        ...v,\n        route: v.route.map(n => state.allNodesMap[n.id])\n      }))\n    };\n    const result = runMetaheuristic(state.algorithmType, currentStateForAlgorithm);\n    if (result.message) {\n      addLog(result.message);\n    }\n    if (result.newState) {\n      setState(s => ({\n        ...s,\n        ...result.newState,\n        animationState: 'paused',\n        algorithmState: 'done'\n      }));\n    } else {\n      setState(s => ({\n        ...s,\n        animationState: 'paused',\n        algorithmState: 'done'\n      }));\n    }\n  }, [state]);\n  const fixedAnimationSpeed = 500;\n  useEffect(() => {\n    const isHybridGreedy = state.algorithmType === ALGORITHM_TYPES.GREEDY_HYBRID;\n    if (state.animationState === 'playing' && state.algorithmState !== 'done' && isHybridGreedy) {\n      const timer = setTimeout(() => {\n        runStep();\n      }, fixedAnimationSpeed);\n      return () => clearTimeout(timer);\n    }\n  }, [state.animationState, state.algorithmState, state.algorithmType, runStep]);\n  const handleRunComparison = () => {\n    addLog(\"--- STARTING COMPARISON RUN ---\");\n    setState(s => ({\n      ...s,\n      comparisonResults: [],\n      algorithmState: 'running'\n    }));\n    const algorithmsToTest = Object.keys(ALGORITHM_TYPES).map(key => ALGORITHM_TYPES[key]);\n    const results = [];\n    algorithmsToTest.forEach(algoName => {\n      let currentState = getInitialState(selectedDataset);\n      currentState.algorithmType = algoName;\n      let result = {\n        distance: Infinity,\n        vehicles: 0\n      };\n      if (algoName === ALGORITHM_TYPES.GREEDY_HYBRID) {\n        let safetyCounter = 0;\n        while (currentState.unvisitedCustomerIds.length > 0) {\n          safetyCounter++;\n          if (safetyCounter > 10000) {\n            currentState.algorithmState = 'done';\n            break;\n          }\n          if (currentState.algorithmState === 'idle') {\n            const stepResult = hybridGreedyStep(currentState);\n            if (stepResult.newState) currentState = {\n              ...currentState,\n              ...stepResult.newState\n            };else if (stepResult.nextState) currentState.algorithmState = stepResult.nextState;\n          }\n          if (currentState.algorithmState === 'clustering') {\n            let clusteringDone = false;\n            while (!clusteringDone) {\n              const stepResult = hybridGreedyStep(currentState);\n              if (stepResult.nextState === 'solving_tsp') {\n                currentState.algorithmState = 'solving_tsp';\n                clusteringDone = true;\n              } else if (stepResult.newState) {\n                currentState = {\n                  ...currentState,\n                  ...stepResult.newState\n                };\n              } else {\n                currentState.algorithmState = 'solving_tsp';\n                clusteringDone = true;\n              }\n              if (safetyCounter++ > 10000) break;\n            }\n          }\n          if (currentState.algorithmState === 'solving_tsp') {\n            const stepResult = hybridGreedyStep(currentState);\n            if (stepResult.newState) {\n              currentState = {\n                ...currentState,\n                ...stepResult.newState\n              };\n              currentState.algorithmState = 'idle';\n            }\n          }\n        }\n        result = {\n          distance: currentState.totalDistance,\n          vehicles: currentState.vehicles.length\n        };\n      } else {\n        const metaResult = runMetaheuristic(algoName, currentState);\n        if (metaResult.newState) {\n          result = {\n            distance: metaResult.newState.totalDistance,\n            vehicles: metaResult.newState.vehicles.length\n          };\n        }\n      }\n      if (result && result.distance !== Infinity) {\n        addLog(`[COMPARE] ${algoName}: Dist=${result.distance.toFixed(2)}, Vehicles=${result.vehicles}`);\n        results.push({\n          name: algoName,\n          distance: result.distance,\n          vehicles: result.vehicles,\n          color: COMPARISON_COLORS[algoName]\n        });\n      }\n    });\n    const bestResult = results.length > 0 ? results.reduce((best, current) => current.distance < best.distance ? current : best, results[0]) : null;\n    if (bestResult) {\n      addLog(`--- COMPARISON COMPLETE --- Best Result: ${bestResult.name} (${bestResult.distance.toFixed(2)})`);\n    } else {\n      addLog(\"--- COMPARISON COMPLETE --- No valid results found.\");\n    }\n    setState(s => ({\n      ...getInitialState(selectedDataset),\n      algorithmType: s.algorithmType,\n      comparisonResults: results,\n      logMessages: [...s.logMessages, `Comparison finished. Results in Summary tab.`],\n      algorithmState: 'done'\n    }));\n  };\n  const handleAlgorithmChange = type => {\n    const resetState = getInitialState(selectedDataset);\n    setState({\n      ...resetState,\n      comparisonResults: [],\n      algorithmType: type,\n      logMessages: [`Algorithm changed to ${type}.`]\n    });\n  };\n  const handlePlayPause = () => {\n    if (state.algorithmState === 'done') return;\n    const isHybridGreedy = state.algorithmType === ALGORITHM_TYPES.GREEDY_HYBRID;\n    if (isHybridGreedy) {\n      setState(s => ({\n        ...s,\n        animationState: s.animationState === 'playing' ? 'paused' : 'playing'\n      }));\n    } else {\n      runMetaheuristicFull();\n    }\n  };\n  const handleNextStep = () => {\n    if (state.animationState === 'playing' || state.algorithmState === 'done') return;\n    if (state.algorithmType !== ALGORITHM_TYPES.GREEDY_HYBRID) {\n      addLog(`'Next Step' is only available for the Hybrid Greedy algorithm.`);\n      return;\n    }\n    runStep();\n  };\n  const handleReset = () => {\n    setState(getInitialState(selectedDataset));\n  };\n  const handleDatasetChange = datasetName => {\n    setSelectedDataset(datasetName);\n    setState(getInitialState(datasetName));\n  };\n  return {\n    state,\n    selectedDataset,\n    handlePlayPause,\n    handleNextStep,\n    handleReset,\n    handleDatasetChange,\n    handleAlgorithmChange,\n    handleRunComparison\n  };\n};\n_s(useCvrpAlgorithm, \"6lxO/nw+RDJ9+xLPf1MkmzHBSYc=\");","map":{"version":3,"names":["useState","useEffect","useCallback","sampleDatasets","vehicleColors","ALGORITHM_TYPES","COMPARISON_COLORS","runAlgorithmStep","runMetaheuristic","hybridGreedyStep","getInitialState","datasetName","data","allNodes","depot","customers","nodeMap","reduce","acc","node","id","dataset","capacity","allNodesMap","customerNodes","unvisitedCustomerIds","map","c","vehicles","currentVehicleId","algorithmState","algorithmType","GREEDY_HYBRID","animationState","logMessages","totalDistance","comparisonResults","useCvrpAlgorithm","initialDatasetName","_s","selectedDataset","setSelectedDataset","state","setState","addLog","message","prevState","runStep","currentStateForAlgorithm","v","route","n","result","newState","s","nextState","runMetaheuristicFull","fixedAnimationSpeed","isHybridGreedy","timer","setTimeout","clearTimeout","handleRunComparison","algorithmsToTest","Object","keys","key","results","forEach","algoName","currentState","distance","Infinity","safetyCounter","length","stepResult","clusteringDone","metaResult","toFixed","push","name","color","bestResult","best","current","handleAlgorithmChange","type","resetState","handlePlayPause","handleNextStep","handleReset","handleDatasetChange"],"sources":["C:/Users/ASUS/OneDrive/Desktop/cvrp-visualizer/src/hooks/useCvrpAlgorithm.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { sampleDatasets } from '../constants/datasets';\r\nimport { vehicleColors } from '../constants/vehicleColors';\r\nimport { ALGORITHM_TYPES, COMPARISON_COLORS } from '../constants/algorithms';\r\nimport { runAlgorithmStep, runMetaheuristic, hybridGreedyStep } from '../algorithms'; \r\n\r\n\r\nconst getInitialState = (datasetName) => {\r\n  const data = sampleDatasets[datasetName];\r\n  const allNodes = [data.depot, ...data.customers];\r\n  const nodeMap = allNodes.reduce((acc, node) => {\r\n    acc[node.id] = node;\r\n    return acc;\r\n  }, {});\r\n  \r\n  return {\r\n    dataset: data,\r\n    depot: data.depot,\r\n    capacity: data.capacity,\r\n    allNodesMap: nodeMap,\r\n    customerNodes: data.customers,\r\n    unvisitedCustomerIds: data.customers.map(c => c.id),\r\n    vehicles: [],\r\n    currentVehicleId: 0,\r\n    vehicleColors: vehicleColors,\r\n    \r\n    algorithmState: 'idle', \r\n    algorithmType: ALGORITHM_TYPES.GREEDY_HYBRID,\r\n    animationState: 'paused',\r\n    logMessages: [`Selected dataset: ${datasetName}. Select an algorithm and run.`],\r\n    totalDistance: 0,\r\n    \r\n    comparisonResults: [],\r\n  };\r\n};\r\n\r\nexport const useCvrpAlgorithm = (initialDatasetName) => {\r\n  const [selectedDataset, setSelectedDataset] = useState(initialDatasetName);\r\n  const [state, setState] = useState(() => getInitialState(initialDatasetName));\r\n\r\n  const addLog = (message) => {\r\n    setState(prevState => ({\r\n      ...prevState,\r\n      logMessages: [...prevState.logMessages, message],\r\n    }));\r\n  };\r\n\r\n  const runStep = useCallback(() => {\r\n    if (state.algorithmState === 'done') return;\r\n    \r\n    const currentStateForAlgorithm = {\r\n        ...state,\r\n        vehicles: state.vehicles.map(v => ({\r\n            ...v, \r\n            route: v.route.map(n => state.allNodesMap[n.id]), \r\n        })),\r\n    };\r\n\r\n    const result = runAlgorithmStep(state.algorithmType, currentStateForAlgorithm);\r\n    \r\n    if (result.message) {\r\n      addLog(result.message);\r\n    }\r\n    \r\n    if (result.newState) {\r\n      setState(s => ({ ...s, ...result.newState }));\r\n    } else if (result.nextState) {\r\n      setState(s => ({ ...s, algorithmState: result.nextState }));\r\n    }\r\n  }, [state]);\r\n\r\n\r\n  const runMetaheuristicFull = useCallback(() => {\r\n    addLog(`Running ${state.algorithmType} in full optimization mode...`);\r\n    setState(s => ({ ...s, comparisonResults: [], animationState: 'running', algorithmState: 'running' }));\r\n    \r\n    const currentStateForAlgorithm = {\r\n        ...state,\r\n        vehicles: state.vehicles.map(v => ({\r\n            ...v, \r\n            route: v.route.map(n => state.allNodesMap[n.id]),\r\n        })),\r\n    };\r\n\r\n    const result = runMetaheuristic(state.algorithmType, currentStateForAlgorithm);\r\n    \r\n    if (result.message) {\r\n        addLog(result.message);\r\n    }\r\n\r\n    if (result.newState) {\r\n        setState(s => ({ ...s, ...result.newState, animationState: 'paused', algorithmState: 'done' }));\r\n    } else {\r\n        setState(s => ({ ...s, animationState: 'paused', algorithmState: 'done' }));\r\n    }\r\n  }, [state]);\r\n\r\n  const fixedAnimationSpeed = 500; \r\n\r\n  useEffect(() => {\r\n    const isHybridGreedy = state.algorithmType === ALGORITHM_TYPES.GREEDY_HYBRID;\r\n    \r\n    if (state.animationState === 'playing' && state.algorithmState !== 'done' && isHybridGreedy) {\r\n      const timer = setTimeout(() => {\r\n        runStep();\r\n      }, fixedAnimationSpeed);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [state.animationState, state.algorithmState, state.algorithmType, runStep]);\r\n\r\n\r\n  const handleRunComparison = () => {\r\n    addLog(\"--- STARTING COMPARISON RUN ---\");\r\n    setState(s => ({ ...s, comparisonResults: [], algorithmState: 'running' })); \r\n    \r\n    const algorithmsToTest = Object.keys(ALGORITHM_TYPES).map(key => ALGORITHM_TYPES[key]);\r\n    const results = [];\r\n    \r\n    algorithmsToTest.forEach(algoName => {\r\n        let currentState = getInitialState(selectedDataset);\r\n        currentState.algorithmType = algoName;\r\n        let result = { distance: Infinity, vehicles: 0 };\r\n        \r\n        if (algoName === ALGORITHM_TYPES.GREEDY_HYBRID) {\r\n            let safetyCounter = 0;\r\n            \r\n            while (currentState.unvisitedCustomerIds.length > 0) {\r\n                safetyCounter++;\r\n                if (safetyCounter > 10000) { \r\n                    currentState.algorithmState = 'done';\r\n                    break;\r\n                }\r\n                \r\n                if (currentState.algorithmState === 'idle') {\r\n                    const stepResult = hybridGreedyStep(currentState);\r\n                    if (stepResult.newState) currentState = { ...currentState, ...stepResult.newState };\r\n                    else if (stepResult.nextState) currentState.algorithmState = stepResult.nextState;\r\n\r\n                } \r\n                \r\n                if (currentState.algorithmState === 'clustering') {\r\n                    let clusteringDone = false;\r\n                    while (!clusteringDone) {\r\n                        const stepResult = hybridGreedyStep(currentState);\r\n                        if (stepResult.nextState === 'solving_tsp') {\r\n                            currentState.algorithmState = 'solving_tsp';\r\n                            clusteringDone = true;\r\n                        } else if (stepResult.newState) {\r\n                            currentState = { ...currentState, ...stepResult.newState };\r\n                        } else {\r\n                            currentState.algorithmState = 'solving_tsp'; \r\n                            clusteringDone = true;\r\n                        }\r\n                        if (safetyCounter++ > 10000) break;\r\n                    }\r\n                }\r\n                \r\n                if (currentState.algorithmState === 'solving_tsp') {\r\n                    const stepResult = hybridGreedyStep(currentState);\r\n                    if (stepResult.newState) {\r\n                        currentState = { ...currentState, ...stepResult.newState };\r\n                        currentState.algorithmState = 'idle'; \r\n                    }\r\n                }\r\n            }\r\n            \r\n            result = {\r\n                distance: currentState.totalDistance,\r\n                vehicles: currentState.vehicles.length,\r\n            };\r\n\r\n        } else {\r\n            const metaResult = runMetaheuristic(algoName, currentState);\r\n            if (metaResult.newState) {\r\n                result = {\r\n                    distance: metaResult.newState.totalDistance,\r\n                    vehicles: metaResult.newState.vehicles.length,\r\n                };\r\n            }\r\n        }\r\n        \r\n        if (result && result.distance !== Infinity) {\r\n            addLog(`[COMPARE] ${algoName}: Dist=${result.distance.toFixed(2)}, Vehicles=${result.vehicles}`);\r\n            results.push({ \r\n                name: algoName, \r\n                distance: result.distance, \r\n                vehicles: result.vehicles, \r\n                color: COMPARISON_COLORS[algoName] \r\n            });\r\n        }\r\n    });\r\n\r\n    const bestResult = results.length > 0 ? results.reduce((best, current) => current.distance < best.distance ? current : best, results[0]) : null;\r\n    if (bestResult) {\r\n        addLog(`--- COMPARISON COMPLETE --- Best Result: ${bestResult.name} (${bestResult.distance.toFixed(2)})`);\r\n    } else {\r\n        addLog(\"--- COMPARISON COMPLETE --- No valid results found.\");\r\n    }\r\n    \r\n    setState(s => ({ \r\n        ...getInitialState(selectedDataset),\r\n        algorithmType: s.algorithmType,\r\n        comparisonResults: results, \r\n        logMessages: [...s.logMessages, `Comparison finished. Results in Summary tab.`],\r\n        algorithmState: 'done'\r\n    }));\r\n  };\r\n\r\n  const handleAlgorithmChange = (type) => {\r\n    const resetState = getInitialState(selectedDataset);\r\n    setState({ ...resetState, comparisonResults: [], algorithmType: type, logMessages: [`Algorithm changed to ${type}.`] });\r\n  };\r\n  \r\n  const handlePlayPause = () => {\r\n    if (state.algorithmState === 'done') return;\r\n    \r\n    const isHybridGreedy = state.algorithmType === ALGORITHM_TYPES.GREEDY_HYBRID;\r\n    \r\n    if (isHybridGreedy) {\r\n        setState(s => ({\r\n          ...s,\r\n          animationState: s.animationState === 'playing' ? 'paused' : 'playing',\r\n        }));\r\n    } else {\r\n        runMetaheuristicFull();\r\n    }\r\n  };\r\n  \r\n  const handleNextStep = () => {\r\n    if (state.animationState === 'playing' || state.algorithmState === 'done') return;\r\n    if (state.algorithmType !== ALGORITHM_TYPES.GREEDY_HYBRID) {\r\n        addLog(`'Next Step' is only available for the Hybrid Greedy algorithm.`);\r\n        return;\r\n    }\r\n    \r\n    runStep();\r\n  };\r\n  \r\n  const handleReset = () => {\r\n    setState(getInitialState(selectedDataset));\r\n  };\r\n  \r\n  const handleDatasetChange = (datasetName) => {\r\n    setSelectedDataset(datasetName);\r\n    setState(getInitialState(datasetName));\r\n  };\r\n  \r\n\r\n  return {\r\n    state,\r\n    selectedDataset,\r\n    handlePlayPause,\r\n    handleNextStep,\r\n    handleReset,\r\n    handleDatasetChange,\r\n    handleAlgorithmChange,\r\n    handleRunComparison\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}