{"ast":null,"code":"import { getDistance, calculateRouteDistance } from './geometry';\nimport { solveTspNearestNeighbor } from './solveTsp';\n\n// Internal constants for routing logic\nconst ALGORITHM_TYPES = {\n  GREEDY_HYBRID: 'Hybrid Greedy (Clustering + NN TSP)',\n  GENETIC_ALGORITHM: 'Simplified Genetic Algorithm (GA)',\n  TABU_SEARCH: 'Simplified Tabu Search (TS)',\n  ANT_COLONY_OPTIMIZATION: 'Simplified Ant Colony Optimization (ACO)'\n};\n\n// --- UTILITY FUNCTIONS ---\n\n/**\r\n * Converts a customer permutation into feasible vehicle routes based on capacity.\r\n */\nconst splitRoutesByCapacity = (customerIds, allNodesMap, depot, capacity, color) => {\n  const routes = [];\n  let currentRoute = [depot];\n  let currentLoad = 0;\n  let vehicleId = 1;\n  for (const id of customerIds) {\n    const customer = allNodesMap[id];\n    if (currentLoad + customer.demand > capacity) {\n      currentRoute.push(depot); // End current route at depot\n      routes.push({\n        id: vehicleId,\n        route: currentRoute,\n        color: color,\n        initialCapacity: capacity,\n        capacityLeft: capacity\n      });\n\n      // Start new route with the current customer\n      currentRoute = [depot, customer];\n      currentLoad = customer.demand;\n      vehicleId++;\n    } else {\n      currentRoute.push(customer);\n      currentLoad += customer.demand;\n    }\n  }\n  if (currentRoute.length > 1) {\n    currentRoute.push(depot);\n    routes.push({\n      id: vehicleId,\n      route: currentRoute,\n      color: color,\n      initialCapacity: capacity,\n      capacityLeft: capacity\n    });\n  }\n\n  // Apply NN-TSP optimization to each final route\n  const finalRoutes = routes.map(v => {\n    const customerCluster = v.route.filter(n => n.id !== depot.id);\n    const optimizedRoute = solveTspNearestNeighbor(customerCluster, depot);\n    return {\n      ...v,\n      route: optimizedRoute\n    };\n  });\n  return finalRoutes;\n};\n\n// --- HYBRID GREEDY IMPLEMENTATION (Step-by-step for visualization) ---\n\nexport const hybridGreedyStep = state => {\n  const {\n    currentVehicleId,\n    vehicles,\n    allNodesMap,\n    unvisitedCustomerIds\n  } = state;\n  const currentVehicle = vehicles.find(v => v.id === currentVehicleId);\n\n  // 1. START NEW VEHICLE (IDLE state)\n  if (state.algorithmState === 'idle') {\n    if (unvisitedCustomerIds.length === 0) {\n      return {\n        message: \"All customers served. Solution complete.\",\n        nextState: 'done'\n      };\n    }\n    const newVehicleId = currentVehicleId + 1;\n    const startCustomerId = unvisitedCustomerIds[0];\n    const startCustomer = allNodesMap[startCustomerId];\n    if (startCustomer.demand > state.capacity) {\n      return {\n        message: `Error: Customer ${startCustomer.id} demand exceeds vehicle capacity. Stopping.`,\n        nextState: 'done'\n      };\n    }\n    const newVehicle = {\n      id: newVehicleId,\n      route: [state.depot, startCustomer],\n      capacityLeft: state.capacity - startCustomer.demand,\n      initialCapacity: state.capacity,\n      color: state.vehicleColors[newVehicleId % state.vehicleColors.length]\n    };\n    const newUnvisitedIds = unvisitedCustomerIds.filter(id => id !== startCustomerId);\n    return {\n      message: `[V${newVehicleId}] Starting new route. Added first customer C${startCustomer.id}.`,\n      newState: {\n        vehicles: [...vehicles, newVehicle],\n        currentVehicleId: newVehicleId,\n        unvisitedCustomerIds: newUnvisitedIds,\n        algorithmState: 'clustering'\n      }\n    };\n  }\n\n  // 2. CLUSTERING STEP\n  if (state.algorithmState === 'clustering') {\n    const availableCustomerIds = unvisitedCustomerIds.filter(id => allNodesMap[id].demand <= currentVehicle.capacityLeft);\n    if (availableCustomerIds.length === 0) {\n      return {\n        message: `[V${currentVehicleId}] No more customers fit. Moving to TSP solve.`,\n        nextState: 'solving_tsp'\n      };\n    }\n    let bestCustomerId = -1;\n    let minDistance = Infinity;\n    let lastNode = currentVehicle.route[currentVehicle.route.length - 1];\n\n    // Find nearest unvisited customer from the last added node\n    for (const customerId of availableCustomerIds) {\n      const customerNode = allNodesMap[customerId];\n      const distance = getDistance(lastNode, customerNode);\n      if (distance < minDistance) {\n        minDistance = distance;\n        bestCustomerId = customerId;\n      }\n    }\n    if (bestCustomerId !== -1) {\n      const bestCustomer = allNodesMap[bestCustomerId];\n      const newRoute = [...currentVehicle.route, bestCustomer];\n      const newCapacityLeft = currentVehicle.capacityLeft - bestCustomer.demand;\n      const newUnvisitedIds = unvisitedCustomerIds.filter(id => id !== bestCustomerId);\n      const newVehicles = vehicles.map(v => v.id === currentVehicleId ? {\n        ...v,\n        route: newRoute,\n        capacityLeft: newCapacityLeft\n      } : v);\n      return {\n        message: `[V${currentVehicleId}] Added nearest C${bestCustomer.id}. Capacity left: ${newCapacityLeft.toFixed(1)}.`,\n        newState: {\n          vehicles: newVehicles,\n          unvisitedCustomerIds: newUnvisitedIds\n        }\n      };\n    }\n  }\n\n  // 3. TSP SOLVING STEP\n  if (state.algorithmState === 'solving_tsp') {\n    const vehicleToSolve = state.vehicles.find(v => v.id === currentVehicleId);\n    if (!vehicleToSolve) {\n      return {\n        message: `Error: Vehicle ${currentVehicleId} not found for TSP solve.`,\n        nextState: 'idle'\n      };\n    }\n    const customerCluster = vehicleToSolve.route.filter(n => n.id !== state.depot.id);\n    const optimizedRoute = solveTspNearestNeighbor(customerCluster, state.depot);\n    const routeDistance = calculateRouteDistance(optimizedRoute);\n    const newVehicles = vehicles.map(v => v.id === currentVehicleId ? {\n      ...v,\n      route: optimizedRoute\n    } : v);\n    return {\n      message: `[V${currentVehicleId}] Optimized route (NN-TSP). Dist: ${routeDistance.toFixed(2)}.`,\n      newState: {\n        vehicles: newVehicles,\n        totalDistance: state.totalDistance + routeDistance,\n        algorithmState: 'idle' // Ready for next vehicle\n      }\n    };\n  }\n  return {\n    message: \"Error: Algorithm state mismatch.\",\n    nextState: 'done'\n  };\n};\n\n// --- METAHEURISTIC IMPLEMENTATIONS (Simplified, full run) ---\n\nconst geneticAlgorithm = state => {\n  const {\n    customerNodes,\n    depot,\n    capacity,\n    allNodesMap,\n    vehicleColors\n  } = state;\n  const initialPermutation = [...customerNodes].map(c => c.id).sort(() => Math.random() - 0.5);\n  let bestPermutation = [...initialPermutation];\n  let bestDistance = Infinity;\n  for (let gen = 0; gen < 50; gen++) {\n    // Fixed 50 generations for quick simulation\n    let newPermutation = [...bestPermutation];\n    const i = Math.floor(Math.random() * newPermutation.length);\n    const j = Math.floor(Math.random() * newPermutation.length);\n    [newPermutation[i], newPermutation[j]] = [newPermutation[j], newPermutation[i]];\n    const newRoutes = splitRoutesByCapacity(newPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\n    const newTotalDistance = newRoutes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\n    if (newTotalDistance < bestDistance) {\n      bestDistance = newTotalDistance;\n      bestPermutation = newPermutation;\n    }\n  }\n  const finalVehicles = splitRoutesByCapacity(bestPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\n  const finalTotalDistance = finalVehicles.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\n  return {\n    message: `GA complete. Found ${finalVehicles.length} vehicles. Total distance: ${finalTotalDistance.toFixed(2)}.`,\n    newState: {\n      vehicles: finalVehicles.map((v, i) => ({\n        ...v,\n        id: i + 1,\n        color: state.vehicleColors[(i + 1) % state.vehicleColors.length]\n      })),\n      totalDistance: finalTotalDistance\n    }\n  };\n};\nconst tabuSearch = state => {\n  const {\n    customerNodes,\n    depot,\n    capacity,\n    allNodesMap,\n    vehicleColors\n  } = state;\n  let currentPermutation = [...customerNodes].map(c => c.id).sort((a, b) => getDistance(allNodesMap[a], depot) - getDistance(allNodesMap[b], depot));\n  let currentRoutes = splitRoutesByCapacity(currentPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\n  let currentDistance = currentRoutes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\n  let bestPermutation = [...currentPermutation];\n  let bestDistance = currentDistance;\n  const tabuList = [];\n  const tabuTenure = 5;\n  for (let iter = 0; iter < 50; iter++) {\n    // Fixed 50 iterations\n    let bestMove = null;\n    let bestNeighborDistance = Infinity;\n    for (let i = 0; i < currentPermutation.length; i++) {\n      for (let j = i + 1; j < currentPermutation.length; j++) {\n        let neighborPermutation = [...currentPermutation];\n        [neighborPermutation[i], neighborPermutation[j]] = [neighborPermutation[j], neighborPermutation[i]];\n        const moveKey = `${i}-${j}`;\n        const neighborRoutes = splitRoutesByCapacity(neighborPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\n        const neighborDistance = neighborRoutes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\n        const isTabu = tabuList.some(t => t.move === moveKey && t.iteration >= iter);\n        if (neighborDistance < bestNeighborDistance && (!isTabu || neighborDistance < bestDistance)) {\n          bestNeighborDistance = neighborDistance;\n          bestMove = {\n            i,\n            j,\n            permutation: neighborPermutation\n          };\n        }\n      }\n    }\n    if (!bestMove) break;\n    currentPermutation = bestMove.permutation;\n    currentDistance = bestNeighborDistance;\n    const moveKey = `${bestMove.i}-${bestMove.j}`;\n    tabuList.push({\n      move: moveKey,\n      iteration: iter + tabuTenure\n    });\n    if (currentDistance < bestDistance) {\n      bestDistance = currentDistance;\n      bestPermutation = currentPermutation;\n    }\n  }\n  const finalVehicles = splitRoutesByCapacity(bestPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\n  const finalTotalDistance = finalVehicles.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\n  return {\n    message: `TS complete. Found ${finalVehicles.length} vehicles. Total distance: ${finalTotalDistance.toFixed(2)}.`,\n    newState: {\n      vehicles: finalVehicles.map((v, i) => ({\n        ...v,\n        id: i + 1,\n        color: state.vehicleColors[(i + 1) % state.vehicleColors.length]\n      })),\n      totalDistance: finalTotalDistance\n    }\n  };\n};\nconst antColonyOptimization = state => {\n  const {\n    customerNodes,\n    depot,\n    capacity,\n    allNodesMap\n  } = state;\n  const customers = customerNodes.map(c => c.id);\n  const numCustomers = customers.length;\n  const numAnts = 10;\n  const numIterations = 50;\n  const alpha = 1;\n  const beta = 2;\n  const evaporationRate = 0.5;\n  const initialPheromone = 1;\n  const allNodesIds = [depot.id, ...customers];\n  const pheromone = new Map();\n  const getPheromoneKey = (id1, id2) => Math.min(id1, id2) + '-' + Math.max(id1, id2);\n  for (let i = 0; i < allNodesIds.length; i++) {\n    for (let j = i + 1; j < allNodesIds.length; j++) {\n      pheromone.set(getPheromoneKey(allNodesIds[i], allNodesIds[j]), initialPheromone);\n    }\n  }\n  let bestPermutation = [];\n  let bestDistance = Infinity;\n  for (let iter = 0; iter < numIterations; iter++) {\n    const solutions = [];\n    for (let ant = 0; ant < numAnts; ant++) {\n      let visited = new Set();\n      let currentPermutation = [];\n      let currentNode = depot.id;\n      while (visited.size < numCustomers) {\n        const unvisited = customers.filter(id => !visited.has(id));\n        let totalTractiveness = 0;\n        const tractiveness = new Map();\n        for (const nextId of unvisited) {\n          const dist = getDistance(allNodesMap[currentNode], allNodesMap[nextId]);\n          const tau = pheromone.get(getPheromoneKey(currentNode, nextId)) || initialPheromone;\n          const eta = 1 / (dist + 1e-6);\n          const value = Math.pow(tau, alpha) * Math.pow(eta, beta);\n          tractiveness.set(nextId, value);\n          totalTractiveness += value;\n        }\n        if (totalTractiveness === 0) break;\n        let r = Math.random() * totalTractiveness;\n        let nextNode = -1;\n        for (const [id, value] of tractiveness) {\n          r -= value;\n          if (r <= 0) {\n            nextNode = id;\n            break;\n          }\n        }\n        if (nextNode !== -1) {\n          currentPermutation.push(nextNode);\n          visited.add(nextNode);\n          currentNode = nextNode;\n        } else {\n          break;\n        }\n      }\n      const routes = splitRoutesByCapacity(currentPermutation, allNodesMap, depot, capacity, state.vehicleColors[1]);\n      const totalDistance = routes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\n      solutions.push({\n        permutation: currentPermutation,\n        distance: totalDistance,\n        routes: routes\n      });\n      if (totalDistance < bestDistance) {\n        bestDistance = totalDistance;\n        bestPermutation = currentPermutation;\n      }\n    }\n    for (const [key, value] of pheromone) {\n      pheromone.set(key, value * (1 - evaporationRate));\n    }\n    const iterationBest = solutions.reduce((best, current) => current.distance < best.distance ? current : best, solutions[0]);\n    if (iterationBest) {\n      const Q = 1000;\n      const deposit = Q / iterationBest.distance;\n      let path = [depot.id, ...iterationBest.permutation];\n      for (let k = 0; k < path.length - 1; k++) {\n        const key = getPheromoneKey(path[k], path[k + 1]);\n        pheromone.set(key, (pheromone.get(key) || initialPheromone) + deposit);\n      }\n    }\n  }\n  const finalVehicles = splitRoutesByCapacity(bestPermutation, allNodesMap, depot, capacity, state.vehicleColors[1]);\n  const finalTotalDistance = finalVehicles.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\n  return {\n    message: `ACO complete. Found ${finalVehicles.length} vehicles. Total distance: ${finalTotalDistance.toFixed(2)}.`,\n    newState: {\n      vehicles: finalVehicles.map((v, i) => ({\n        ...v,\n        id: i + 1,\n        color: state.vehicleColors[(i + 1) % state.vehicleColors.length]\n      })),\n      totalDistance: finalTotalDistance\n    }\n  };\n};\n\n// --- ALGORITHM DISPATCHERS ---\n\n/**\r\n * Master function to dispatch the correct algorithm logic step (for step mode).\r\n */\nexport const runAlgorithmStep = (algorithmType, state) => {\n  switch (algorithmType) {\n    case ALGORITHM_TYPES.GREEDY_HYBRID:\n      return hybridGreedyStep(state);\n    default:\n      throw new Error(`Invalid algorithm type: ${algorithmType}`);\n  }\n};\n\n/**\r\n * Runs a metaheuristic algorithm (GA, TS, ACO) to completion in a single call (for full run and comparison).\r\n */\nexport const runMetaheuristic = (algorithmType, state) => {\n  let result;\n  switch (algorithmType) {\n    case ALGORITHM_TYPES.GENETIC_ALGORITHM:\n      result = geneticAlgorithm(state);\n      break;\n    case ALGORITHM_TYPES.TABU_SEARCH:\n      result = tabuSearch(state);\n      break;\n    case ALGORITHM_TYPES.ANT_COLONY_OPTIMIZATION:\n      result = antColonyOptimization(state);\n      break;\n    default:\n      throw new Error(`Algorithm type ${algorithmType} not supported for full run.`);\n  }\n  return {\n    ...result,\n    newState: {\n      ...result.newState,\n      algorithmState: 'done'\n    }\n  };\n};","map":{"version":3,"names":["getDistance","calculateRouteDistance","solveTspNearestNeighbor","ALGORITHM_TYPES","GREEDY_HYBRID","GENETIC_ALGORITHM","TABU_SEARCH","ANT_COLONY_OPTIMIZATION","splitRoutesByCapacity","customerIds","allNodesMap","depot","capacity","color","routes","currentRoute","currentLoad","vehicleId","id","customer","demand","push","route","initialCapacity","capacityLeft","length","finalRoutes","map","v","customerCluster","filter","n","optimizedRoute","hybridGreedyStep","state","currentVehicleId","vehicles","unvisitedCustomerIds","currentVehicle","find","algorithmState","message","nextState","newVehicleId","startCustomerId","startCustomer","newVehicle","vehicleColors","newUnvisitedIds","newState","availableCustomerIds","bestCustomerId","minDistance","Infinity","lastNode","customerId","customerNode","distance","bestCustomer","newRoute","newCapacityLeft","newVehicles","toFixed","vehicleToSolve","routeDistance","totalDistance","geneticAlgorithm","customerNodes","initialPermutation","c","sort","Math","random","bestPermutation","bestDistance","gen","newPermutation","i","floor","j","newRoutes","newTotalDistance","reduce","sum","finalVehicles","finalTotalDistance","tabuSearch","currentPermutation","a","b","currentRoutes","currentDistance","tabuList","tabuTenure","iter","bestMove","bestNeighborDistance","neighborPermutation","moveKey","neighborRoutes","neighborDistance","isTabu","some","t","move","iteration","permutation","antColonyOptimization","customers","numCustomers","numAnts","numIterations","alpha","beta","evaporationRate","initialPheromone","allNodesIds","pheromone","Map","getPheromoneKey","id1","id2","min","max","set","solutions","ant","visited","Set","currentNode","size","unvisited","has","totalTractiveness","tractiveness","nextId","dist","tau","get","eta","value","pow","r","nextNode","add","key","iterationBest","best","current","Q","deposit","path","k","runAlgorithmStep","algorithmType","Error","runMetaheuristic","result"],"sources":["C:/Users/ASUS/OneDrive/Desktop/cvrp-visualizer/src/algorithms/index.js"],"sourcesContent":["import { getDistance, calculateRouteDistance } from './geometry';\r\nimport { solveTspNearestNeighbor } from './solveTsp';\r\n\r\n// Internal constants for routing logic\r\nconst ALGORITHM_TYPES = {\r\n    GREEDY_HYBRID: 'Hybrid Greedy (Clustering + NN TSP)',\r\n    GENETIC_ALGORITHM: 'Simplified Genetic Algorithm (GA)',\r\n    TABU_SEARCH: 'Simplified Tabu Search (TS)',\r\n    ANT_COLONY_OPTIMIZATION: 'Simplified Ant Colony Optimization (ACO)',\r\n};\r\n\r\n\r\n// --- UTILITY FUNCTIONS ---\r\n\r\n/**\r\n * Converts a customer permutation into feasible vehicle routes based on capacity.\r\n */\r\nconst splitRoutesByCapacity = (customerIds, allNodesMap, depot, capacity, color) => {\r\n    const routes = [];\r\n    let currentRoute = [depot];\r\n    let currentLoad = 0;\r\n    let vehicleId = 1;\r\n\r\n    for (const id of customerIds) {\r\n        const customer = allNodesMap[id];\r\n        \r\n        if (currentLoad + customer.demand > capacity) {\r\n            currentRoute.push(depot); // End current route at depot\r\n            routes.push({\r\n                id: vehicleId,\r\n                route: currentRoute,\r\n                color: color, \r\n                initialCapacity: capacity,\r\n                capacityLeft: capacity,\r\n            });\r\n\r\n            // Start new route with the current customer\r\n            currentRoute = [depot, customer];\r\n            currentLoad = customer.demand;\r\n            vehicleId++;\r\n        } else {\r\n            currentRoute.push(customer);\r\n            currentLoad += customer.demand;\r\n        }\r\n    }\r\n\r\n    if (currentRoute.length > 1) {\r\n        currentRoute.push(depot);\r\n        routes.push({\r\n            id: vehicleId,\r\n            route: currentRoute,\r\n            color: color,\r\n            initialCapacity: capacity,\r\n            capacityLeft: capacity,\r\n        });\r\n    }\r\n\r\n    // Apply NN-TSP optimization to each final route\r\n    const finalRoutes = routes.map(v => {\r\n        const customerCluster = v.route.filter(n => n.id !== depot.id);\r\n        const optimizedRoute = solveTspNearestNeighbor(customerCluster, depot);\r\n        return { ...v, route: optimizedRoute };\r\n    });\r\n\r\n    return finalRoutes;\r\n};\r\n\r\n// --- HYBRID GREEDY IMPLEMENTATION (Step-by-step for visualization) ---\r\n\r\nexport const hybridGreedyStep = (state) => {\r\n    const { currentVehicleId, vehicles, allNodesMap, unvisitedCustomerIds } = state;\r\n    const currentVehicle = vehicles.find(v => v.id === currentVehicleId);\r\n    \r\n    // 1. START NEW VEHICLE (IDLE state)\r\n    if (state.algorithmState === 'idle') {\r\n        if (unvisitedCustomerIds.length === 0) {\r\n             return { message: \"All customers served. Solution complete.\", nextState: 'done' };\r\n        }\r\n        \r\n        const newVehicleId = currentVehicleId + 1;\r\n        const startCustomerId = unvisitedCustomerIds[0];\r\n        const startCustomer = allNodesMap[startCustomerId];\r\n\r\n        if (startCustomer.demand > state.capacity) {\r\n           return { message: `Error: Customer ${startCustomer.id} demand exceeds vehicle capacity. Stopping.`, nextState: 'done' };\r\n        }\r\n\r\n        const newVehicle = {\r\n            id: newVehicleId,\r\n            route: [state.depot, startCustomer],\r\n            capacityLeft: state.capacity - startCustomer.demand,\r\n            initialCapacity: state.capacity,\r\n            color: state.vehicleColors[newVehicleId % state.vehicleColors.length],\r\n        };\r\n\r\n        const newUnvisitedIds = unvisitedCustomerIds.filter(id => id !== startCustomerId);\r\n\r\n        return {\r\n            message: `[V${newVehicleId}] Starting new route. Added first customer C${startCustomer.id}.`,\r\n            newState: {\r\n                vehicles: [...vehicles, newVehicle],\r\n                currentVehicleId: newVehicleId,\r\n                unvisitedCustomerIds: newUnvisitedIds,\r\n                algorithmState: 'clustering',\r\n            }\r\n        };\r\n    }\r\n\r\n    // 2. CLUSTERING STEP\r\n    if (state.algorithmState === 'clustering') {\r\n        const availableCustomerIds = unvisitedCustomerIds.filter(\r\n            id => allNodesMap[id].demand <= currentVehicle.capacityLeft\r\n        );\r\n\r\n        if (availableCustomerIds.length === 0) {\r\n            return { message: `[V${currentVehicleId}] No more customers fit. Moving to TSP solve.`, nextState: 'solving_tsp' };\r\n        }\r\n\r\n        let bestCustomerId = -1;\r\n        let minDistance = Infinity;\r\n        let lastNode = currentVehicle.route[currentVehicle.route.length - 1];\r\n        \r\n        // Find nearest unvisited customer from the last added node\r\n        for (const customerId of availableCustomerIds) {\r\n            const customerNode = allNodesMap[customerId];\r\n            const distance = getDistance(lastNode, customerNode);\r\n            \r\n            if (distance < minDistance) {\r\n                minDistance = distance;\r\n                bestCustomerId = customerId;\r\n            }\r\n        }\r\n        \r\n        if (bestCustomerId !== -1) {\r\n            const bestCustomer = allNodesMap[bestCustomerId];\r\n            \r\n            const newRoute = [...currentVehicle.route, bestCustomer];\r\n            const newCapacityLeft = currentVehicle.capacityLeft - bestCustomer.demand;\r\n            const newUnvisitedIds = unvisitedCustomerIds.filter(id => id !== bestCustomerId);\r\n            \r\n            const newVehicles = vehicles.map(v => \r\n                v.id === currentVehicleId ? { ...v, route: newRoute, capacityLeft: newCapacityLeft } : v\r\n            );\r\n\r\n            return {\r\n                message: `[V${currentVehicleId}] Added nearest C${bestCustomer.id}. Capacity left: ${newCapacityLeft.toFixed(1)}.`,\r\n                newState: {\r\n                    vehicles: newVehicles,\r\n                    unvisitedCustomerIds: newUnvisitedIds,\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    // 3. TSP SOLVING STEP\r\n    if (state.algorithmState === 'solving_tsp') {\r\n        const vehicleToSolve = state.vehicles.find(v => v.id === currentVehicleId);\r\n        if (!vehicleToSolve) {\r\n            return { message: `Error: Vehicle ${currentVehicleId} not found for TSP solve.`, nextState: 'idle' };\r\n        }\r\n        \r\n        const customerCluster = vehicleToSolve.route.filter(n => n.id !== state.depot.id);\r\n        const optimizedRoute = solveTspNearestNeighbor(customerCluster, state.depot);\r\n\r\n        const routeDistance = calculateRouteDistance(optimizedRoute);\r\n\r\n        const newVehicles = vehicles.map(v =>\r\n            v.id === currentVehicleId ? { ...v, route: optimizedRoute } : v\r\n        );\r\n        \r\n        return {\r\n            message: `[V${currentVehicleId}] Optimized route (NN-TSP). Dist: ${routeDistance.toFixed(2)}.`,\r\n            newState: {\r\n                vehicles: newVehicles,\r\n                totalDistance: state.totalDistance + routeDistance,\r\n                algorithmState: 'idle', // Ready for next vehicle\r\n            }\r\n        };\r\n    }\r\n    \r\n    return { message: \"Error: Algorithm state mismatch.\", nextState: 'done' };\r\n};\r\n\r\n\r\n// --- METAHEURISTIC IMPLEMENTATIONS (Simplified, full run) ---\r\n\r\nconst geneticAlgorithm = (state) => {\r\n    const { customerNodes, depot, capacity, allNodesMap, vehicleColors } = state;\r\n    const initialPermutation = [...customerNodes].map(c => c.id).sort(() => Math.random() - 0.5);\r\n    let bestPermutation = [...initialPermutation];\r\n    let bestDistance = Infinity;\r\n\r\n    for (let gen = 0; gen < 50; gen++) { // Fixed 50 generations for quick simulation\r\n        let newPermutation = [...bestPermutation];\r\n        const i = Math.floor(Math.random() * newPermutation.length);\r\n        const j = Math.floor(Math.random() * newPermutation.length);\r\n        [newPermutation[i], newPermutation[j]] = [newPermutation[j], newPermutation[i]];\r\n        \r\n        const newRoutes = splitRoutesByCapacity(newPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\r\n        const newTotalDistance = newRoutes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\r\n        \r\n        if (newTotalDistance < bestDistance) {\r\n            bestDistance = newTotalDistance;\r\n            bestPermutation = newPermutation;\r\n        }\r\n    }\r\n    const finalVehicles = splitRoutesByCapacity(bestPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\r\n    const finalTotalDistance = finalVehicles.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\r\n    \r\n    return {\r\n        message: `GA complete. Found ${finalVehicles.length} vehicles. Total distance: ${finalTotalDistance.toFixed(2)}.`,\r\n        newState: {\r\n            vehicles: finalVehicles.map((v, i) => ({ ...v, id: i + 1, color: state.vehicleColors[(i + 1) % state.vehicleColors.length] })),\r\n            totalDistance: finalTotalDistance,\r\n        }\r\n    };\r\n};\r\n\r\nconst tabuSearch = (state) => {\r\n    const { customerNodes, depot, capacity, allNodesMap, vehicleColors } = state;\r\n    let currentPermutation = [...customerNodes].map(c => c.id).sort((a, b) => getDistance(allNodesMap[a], depot) - getDistance(allNodesMap[b], depot));\r\n    let currentRoutes = splitRoutesByCapacity(currentPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\r\n    let currentDistance = currentRoutes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\r\n\r\n    let bestPermutation = [...currentPermutation];\r\n    let bestDistance = currentDistance;\r\n    const tabuList = [];\r\n    const tabuTenure = 5;\r\n\r\n    for (let iter = 0; iter < 50; iter++) { // Fixed 50 iterations\r\n        let bestMove = null;\r\n        let bestNeighborDistance = Infinity;\r\n\r\n        for (let i = 0; i < currentPermutation.length; i++) {\r\n            for (let j = i + 1; j < currentPermutation.length; j++) {\r\n                let neighborPermutation = [...currentPermutation];\r\n                [neighborPermutation[i], neighborPermutation[j]] = [neighborPermutation[j], neighborPermutation[i]];\r\n                const moveKey = `${i}-${j}`;\r\n                \r\n                const neighborRoutes = splitRoutesByCapacity(neighborPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\r\n                const neighborDistance = neighborRoutes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\r\n\r\n                const isTabu = tabuList.some(t => t.move === moveKey && t.iteration >= iter);\r\n                \r\n                if (neighborDistance < bestNeighborDistance && (!isTabu || neighborDistance < bestDistance)) {\r\n                    bestNeighborDistance = neighborDistance;\r\n                    bestMove = { i, j, permutation: neighborPermutation };\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!bestMove) break; \r\n\r\n        currentPermutation = bestMove.permutation;\r\n        currentDistance = bestNeighborDistance;\r\n        \r\n        const moveKey = `${bestMove.i}-${bestMove.j}`;\r\n        tabuList.push({ move: moveKey, iteration: iter + tabuTenure });\r\n\r\n        if (currentDistance < bestDistance) {\r\n            bestDistance = currentDistance;\r\n            bestPermutation = currentPermutation;\r\n        }\r\n    }\r\n\r\n    const finalVehicles = splitRoutesByCapacity(bestPermutation, allNodesMap, depot, capacity, vehicleColors[1]);\r\n    const finalTotalDistance = finalVehicles.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\r\n    \r\n    return {\r\n        message: `TS complete. Found ${finalVehicles.length} vehicles. Total distance: ${finalTotalDistance.toFixed(2)}.`,\r\n        newState: {\r\n            vehicles: finalVehicles.map((v, i) => ({ ...v, id: i + 1, color: state.vehicleColors[(i + 1) % state.vehicleColors.length] })),\r\n            totalDistance: finalTotalDistance,\r\n        }\r\n    };\r\n};\r\n\r\nconst antColonyOptimization = (state) => {\r\n    const { customerNodes, depot, capacity, allNodesMap } = state;\r\n    const customers = customerNodes.map(c => c.id);\r\n    const numCustomers = customers.length;\r\n    const numAnts = 10;\r\n    const numIterations = 50; \r\n\r\n    const alpha = 1; \r\n    const beta = 2; \r\n    const evaporationRate = 0.5;\r\n    const initialPheromone = 1;\r\n\r\n    const allNodesIds = [depot.id, ...customers];\r\n    const pheromone = new Map();\r\n    const getPheromoneKey = (id1, id2) => Math.min(id1, id2) + '-' + Math.max(id1, id2);\r\n\r\n    for (let i = 0; i < allNodesIds.length; i++) {\r\n        for (let j = i + 1; j < allNodesIds.length; j++) {\r\n            pheromone.set(getPheromoneKey(allNodesIds[i], allNodesIds[j]), initialPheromone);\r\n        }\r\n    }\r\n\r\n    let bestPermutation = [];\r\n    let bestDistance = Infinity;\r\n\r\n    for (let iter = 0; iter < numIterations; iter++) {\r\n        const solutions = [];\r\n\r\n        for (let ant = 0; ant < numAnts; ant++) {\r\n            let visited = new Set();\r\n            let currentPermutation = [];\r\n            let currentNode = depot.id; \r\n\r\n            while (visited.size < numCustomers) {\r\n                const unvisited = customers.filter(id => !visited.has(id));\r\n                let totalTractiveness = 0;\r\n                const tractiveness = new Map();\r\n\r\n                for (const nextId of unvisited) {\r\n                    const dist = getDistance(allNodesMap[currentNode], allNodesMap[nextId]);\r\n                    const tau = pheromone.get(getPheromoneKey(currentNode, nextId)) || initialPheromone;\r\n                    const eta = 1 / (dist + 1e-6); \r\n\r\n                    const value = Math.pow(tau, alpha) * Math.pow(eta, beta);\r\n                    tractiveness.set(nextId, value);\r\n                    totalTractiveness += value;\r\n                }\r\n                \r\n                if (totalTractiveness === 0) break;\r\n\r\n                let r = Math.random() * totalTractiveness;\r\n                let nextNode = -1;\r\n                for (const [id, value] of tractiveness) {\r\n                    r -= value;\r\n                    if (r <= 0) {\r\n                        nextNode = id;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (nextNode !== -1) {\r\n                    currentPermutation.push(nextNode);\r\n                    visited.add(nextNode);\r\n                    currentNode = nextNode;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const routes = splitRoutesByCapacity(currentPermutation, allNodesMap, depot, capacity, state.vehicleColors[1]);\r\n            const totalDistance = routes.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\r\n            solutions.push({ permutation: currentPermutation, distance: totalDistance, routes: routes });\r\n\r\n            if (totalDistance < bestDistance) {\r\n                bestDistance = totalDistance;\r\n                bestPermutation = currentPermutation;\r\n            }\r\n        }\r\n        \r\n        for (const [key, value] of pheromone) {\r\n            pheromone.set(key, value * (1 - evaporationRate));\r\n        }\r\n\r\n        const iterationBest = solutions.reduce((best, current) => current.distance < best.distance ? current : best, solutions[0]);\r\n\r\n        if (iterationBest) {\r\n            const Q = 1000; \r\n            const deposit = Q / iterationBest.distance;\r\n\r\n            let path = [depot.id, ...iterationBest.permutation];\r\n\r\n            for (let k = 0; k < path.length - 1; k++) {\r\n                const key = getPheromoneKey(path[k], path[k+1]);\r\n                pheromone.set(key, (pheromone.get(key) || initialPheromone) + deposit);\r\n            }\r\n        }\r\n    }\r\n\r\n    const finalVehicles = splitRoutesByCapacity(bestPermutation, allNodesMap, depot, capacity, state.vehicleColors[1]);\r\n    const finalTotalDistance = finalVehicles.reduce((sum, v) => sum + calculateRouteDistance(v.route), 0);\r\n    \r\n    return {\r\n        message: `ACO complete. Found ${finalVehicles.length} vehicles. Total distance: ${finalTotalDistance.toFixed(2)}.`,\r\n        newState: {\r\n            vehicles: finalVehicles.map((v, i) => ({ ...v, id: i + 1, color: state.vehicleColors[(i + 1) % state.vehicleColors.length] })),\r\n            totalDistance: finalTotalDistance,\r\n        }\r\n    };\r\n};\r\n\r\n// --- ALGORITHM DISPATCHERS ---\r\n\r\n/**\r\n * Master function to dispatch the correct algorithm logic step (for step mode).\r\n */\r\nexport const runAlgorithmStep = (algorithmType, state) => {\r\n    switch (algorithmType) {\r\n        case ALGORITHM_TYPES.GREEDY_HYBRID:\r\n            return hybridGreedyStep(state);\r\n        default:\r\n            throw new Error(`Invalid algorithm type: ${algorithmType}`);\r\n    }\r\n};\r\n\r\n/**\r\n * Runs a metaheuristic algorithm (GA, TS, ACO) to completion in a single call (for full run and comparison).\r\n */\r\nexport const runMetaheuristic = (algorithmType, state) => {\r\n    let result;\r\n    switch (algorithmType) {\r\n        case ALGORITHM_TYPES.GENETIC_ALGORITHM:\r\n            result = geneticAlgorithm(state);\r\n            break;\r\n        case ALGORITHM_TYPES.TABU_SEARCH:\r\n            result = tabuSearch(state);\r\n            break;\r\n        case ALGORITHM_TYPES.ANT_COLONY_OPTIMIZATION:\r\n            result = antColonyOptimization(state);\r\n            break;\r\n        default:\r\n            throw new Error(`Algorithm type ${algorithmType} not supported for full run.`);\r\n    }\r\n    \r\n    return {\r\n        ...result,\r\n        newState: {\r\n            ...result.newState,\r\n            algorithmState: 'done',\r\n        }\r\n    };\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}