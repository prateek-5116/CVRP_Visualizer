{"ast":null,"code":"import { getDistance } from './geometry';\n\n/**\r\n * Solves TSP for a cluster using Nearest Neighbor (Algorithm 1)\r\n * @param {Array} clusterNodes - Array of nodes including depot\r\n * @param {Object} depot - The depot node\r\n * @returns {Array} - The sorted route\r\n */\nexport const solveTspNearestNeighbor = (clusterNodes, depot) => {\n  if (clusterNodes.length === 0) return [];\n  if (clusterNodes.length === 1) return [depot, clusterNodes[0], depot];\n  let unvisited = [...clusterNodes.filter(n => n.id !== depot.id)];\n  let route = [depot];\n  let currentNode = depot;\n  while (unvisited.length > 0) {\n    let nearestNeighbor = null;\n    let minDistance = Infinity;\n    for (let i = 0; i < unvisited.length; i++) {\n      const distance = getDistance(currentNode, unvisited[i]);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestNeighbor = unvisited[i];\n      }\n    }\n    if (nearestNeighbor) {\n      route.push(nearestNeighbor);\n      currentNode = nearestNeighbor;\n      unvisited = unvisited.filter(n => n.id !== nearestNeighbor.id);\n    } else {\n      break;\n    }\n  }\n  route.push(depot); // Return to depot\n  return route;\n};","map":{"version":3,"names":["getDistance","solveTspNearestNeighbor","clusterNodes","depot","length","unvisited","filter","n","id","route","currentNode","nearestNeighbor","minDistance","Infinity","i","distance","push"],"sources":["C:/Users/ASUS/OneDrive/Desktop/cvrp-visualizer/src/algorithms/solveTsp.js"],"sourcesContent":["import { getDistance } from './geometry';\r\n\r\n/**\r\n * Solves TSP for a cluster using Nearest Neighbor (Algorithm 1)\r\n * @param {Array} clusterNodes - Array of nodes including depot\r\n * @param {Object} depot - The depot node\r\n * @returns {Array} - The sorted route\r\n */\r\nexport const solveTspNearestNeighbor = (clusterNodes, depot) => {\r\n  if (clusterNodes.length === 0) return [];\r\n  if (clusterNodes.length === 1) return [depot, clusterNodes[0], depot];\r\n  \r\n  let unvisited = [...clusterNodes.filter(n => n.id !== depot.id)];\r\n  let route = [depot];\r\n  let currentNode = depot;\r\n\r\n  while (unvisited.length > 0) {\r\n    let nearestNeighbor = null;\r\n    let minDistance = Infinity;\r\n\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n      const distance = getDistance(currentNode, unvisited[i]);\r\n      if (distance < minDistance) {\r\n        minDistance = distance;\r\n        nearestNeighbor = unvisited[i];\r\n      }\r\n    }\r\n\r\n    if (nearestNeighbor) {\r\n      route.push(nearestNeighbor);\r\n      currentNode = nearestNeighbor;\r\n      unvisited = unvisited.filter(n => n.id !== nearestNeighbor.id);\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  route.push(depot); // Return to depot\r\n  return route;\r\n};"],"mappings":"AAAA,SAASA,WAAW,QAAQ,YAAY;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,uBAAuB,GAAGA,CAACC,YAAY,EAAEC,KAAK,KAAK;EAC9D,IAAID,YAAY,CAACE,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;EACxC,IAAIF,YAAY,CAACE,MAAM,KAAK,CAAC,EAAE,OAAO,CAACD,KAAK,EAAED,YAAY,CAAC,CAAC,CAAC,EAAEC,KAAK,CAAC;EAErE,IAAIE,SAAS,GAAG,CAAC,GAAGH,YAAY,CAACI,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKL,KAAK,CAACK,EAAE,CAAC,CAAC;EAChE,IAAIC,KAAK,GAAG,CAACN,KAAK,CAAC;EACnB,IAAIO,WAAW,GAAGP,KAAK;EAEvB,OAAOE,SAAS,CAACD,MAAM,GAAG,CAAC,EAAE;IAC3B,IAAIO,eAAe,GAAG,IAAI;IAC1B,IAAIC,WAAW,GAAGC,QAAQ;IAE1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,SAAS,CAACD,MAAM,EAAEU,CAAC,EAAE,EAAE;MACzC,MAAMC,QAAQ,GAAGf,WAAW,CAACU,WAAW,EAAEL,SAAS,CAACS,CAAC,CAAC,CAAC;MACvD,IAAIC,QAAQ,GAAGH,WAAW,EAAE;QAC1BA,WAAW,GAAGG,QAAQ;QACtBJ,eAAe,GAAGN,SAAS,CAACS,CAAC,CAAC;MAChC;IACF;IAEA,IAAIH,eAAe,EAAE;MACnBF,KAAK,CAACO,IAAI,CAACL,eAAe,CAAC;MAC3BD,WAAW,GAAGC,eAAe;MAC7BN,SAAS,GAAGA,SAAS,CAACC,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKG,eAAe,CAACH,EAAE,CAAC;IAChE,CAAC,MAAM;MACL;IACF;EACF;EAEAC,KAAK,CAACO,IAAI,CAACb,KAAK,CAAC,CAAC,CAAC;EACnB,OAAOM,KAAK;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}